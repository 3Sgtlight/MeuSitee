<!DOCTYPE html>
<html lang="pt-BR">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Reconhecimento Facial — Cyber Verde</title>
<style>
:root{
  --bg:#07110a;
  --panel:#0b1a12;
  --neon:#00ff6a;
  --neon-2:#00d06a;
  --accent:#0fd37a;
  --muted:#8fb29a;
  --glass:rgba(255,255,255,0.02);
  --card-shadow: 0 18px 60px rgba(0,0,0,0.7);
  --radius:14px;
}

/* Reset e base */
*{box-sizing:border-box}
html,body{height:100%;margin:0;font-family:Inter, system-ui, -apple-system, "Segoe UI", Roboto, Arial;color:#dfffe7;
  background:
    radial-gradient(800px 300px at 10% 10%, rgba(0,255,122,0.03), transparent 6%),
    radial-gradient(600px 240px at 90% 90%, rgba(0,208,106,0.02), transparent 6%),
    linear-gradient(180deg,#030806,#07110a);
  -webkit-font-smoothing:antialiased; -moz-osx-font-smoothing:grayscale;}

.container{
  min-height:100vh;
  display:flex;
  align-items:center;
  justify-content:center;
  padding:36px 20px;
}

/* painel principal */
.shell{
  width:100%;
  max-width:1120px;
  display:grid;
  grid-template-columns:360px 1fr;
  gap:22px;
  background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));
  border-radius:18px;
  border:1px solid rgba(0,255,122,0.04);
  padding:18px;
  box-shadow:var(--card-shadow);
  position:relative;
  overflow:hidden;
}
@media (max-width:920px){ .shell{grid-template-columns:1fr;padding:14px} }

/* elementos decorativos cibernéticos */
.holo{
  pointer-events:none;
  position:absolute;
  inset:0;
  background-image:
    linear-gradient(90deg, rgba(0,255,122,0.03) 1px, transparent 1px),
    linear-gradient(180deg, rgba(0,208,106,0.02) 1px, transparent 1px);
  background-size:140px 140px, 180px 180px;
  mix-blend-mode:screen;
}
.scanline{
  position:absolute;left:0;right:0;height:2px;top:0;
  background:linear-gradient(90deg, transparent, rgba(0,255,122,0.12), transparent);
  mix-blend-mode:screen;animation:scan 5s linear infinite;
}
@keyframes scan{0%{top:-8%}50%{top:108%}100%{top:-8%}}

/* painel esquerdo */
.panel{
  background:linear-gradient(180deg, rgba(3,8,5,0.6), rgba(6,14,10,0.6));
  border-radius:12px;padding:16px;border:1px solid rgba(0,255,122,0.05);
  display:flex;flex-direction:column;gap:12px;position:relative;
}

.brand{
  display:flex;gap:12px;align-items:center;
}
.logo{
  width:64px;height:64px;border-radius:12px;
  display:grid;place-items:center;
  background:linear-gradient(135deg,var(--neon),var(--neon-2));
  color:#052016;font-weight:800;font-size:20px;box-shadow:0 8px 30px rgba(0,255,122,0.06);
}
.title h1{margin:0;font-size:18px}
.title p{margin:0;color:var(--muted);font-size:13px}

/* controles */
.controls{display:flex;flex-direction:column;gap:10px}
.row{display:flex;gap:10px;flex-wrap:wrap}
.btn{
  border:0;padding:10px 12px;border-radius:10px;cursor:pointer;font-weight:700;color:#041812;
  background:transparent;border:1px solid rgba(255,255,255,0.02);transition:transform .12s ease;
}
.btn:active{transform:translateY(1px)}
.btn.primary{background:linear-gradient(90deg,var(--neon),var(--neon-2));box-shadow:0 10px 30px rgba(0,255,122,0.06)}
.btn.ghost{background:transparent;color:var(--muted);border:1px solid rgba(255,255,255,0.03)}
.small{padding:8px 10px;font-size:13px;border-radius:8px}

/* status e leituras */
.status{
  background:linear-gradient(180deg, rgba(255,255,255,0.01), rgba(255,255,255,0.00));
  border:1px solid rgba(255,255,255,0.02);padding:10px;border-radius:10px;color:var(--muted);
}
.readouts{display:flex;gap:10px;flex-wrap:wrap}
.readout{padding:8px;border-radius:8px;background:rgba(0,0,0,0.2);min-width:110px;text-align:center;font-size:13px;color:var(--muted)}
.readout strong{display:block;color:var(--neon);font-size:15px}

/* painel direito */
.view{display:flex;flex-direction:column;gap:12px}
.viewer{
  background:linear-gradient(180deg, rgba(255,255,255,0.01), rgba(255,255,255,0.00));
  padding:14px;border-radius:12px;border:1px solid rgba(255,255,255,0.02);
  box-shadow:0 12px 36px rgba(0,0,0,0.6);display:flex;flex-direction:column;gap:12px;
}
.viewer-head{display:flex;justify-content:space-between;align-items:center}
.viewer-head .meta{color:var(--muted);font-size:13px}

/* webcam container estilo cibernético */
#webcam-container{
  min-height:360px;border-radius:12px;overflow:hidden;display:flex;align-items:center;justify-content:center;
  background:
    radial-gradient(500px 160px at 10% 10%, rgba(0,255,122,0.04), transparent 8%),
    radial-gradient(420px 140px at 90% 90%, rgba(0,208,106,0.03), transparent 8%),
    linear-gradient(180deg, rgba(2,6,6,0.6), rgba(4,12,10,0.55));
  position:relative;border:1px solid rgba(0,255,122,0.06);
}
.canvas-frame{padding:8px;border-radius:12px;display:inline-block;box-shadow:inset 0 0 40px rgba(0,255,122,0.02),0 18px 60px rgba(0,0,0,0.6);border:1px solid rgba(0,255,122,0.06)}
canvas{border-radius:10px;max-width:100%;height:auto;display:block;border:1px solid rgba(0,255,122,0.03)}

/* labels estilo HUD — agora visíveis e responsivos para exatamente 3 classes */
#label-container{
  display:flex;
  gap:12px;
  justify-content:center;
  align-items:center;
  flex-wrap:nowrap;
  overflow:hidden;
  padding:6px 4px;
}

/* cada chip ocupa 1/3 do espaço do painel direito para garantir visibilidade */
.hud-chip{
  flex: 1 1 0;
  min-width:0;
  max-width:33%;
  display:flex;
  flex-direction:column;
  align-items:center;
  justify-content:center;
  background:linear-gradient(180deg, rgba(0,255,122,0.05), rgba(0,208,106,0.03));
  color:#001710;
  padding:12px 10px;
  border-radius:12px;
  font-weight:800;
  font-size:15px;
  text-align:center;
  border:1px solid rgba(0,255,122,0.06);
  box-shadow: 0 8px 26px rgba(0,255,122,0.04);
}

/* nome da classe e probabilidade em destaque */
.hud-chip .label{font-size:16px;color:var(--neon);margin-bottom:6px;white-space:nowrap;overflow:hidden;text-overflow:ellipsis}
.hud-chip .prob{font-size:14px;color:#dfffe7}

/* quando houver mais que 3 classes, a visualização prioriza 3 primeiras; ao reduzir para telas pequenas, chips ficam scrolláveis */
@media (max-width:720px){
  #label-container{overflow-x:auto;padding-bottom:8px}
  .hud-chip{max-width:260px;flex:0 0 auto}
}

/* rodapé pequeno */
.foot{display:flex;justify-content:space-between;align-items:center;font-size:12px;color:var(--muted)}

/* acessibilidade foco */
button:focus{outline:3px solid rgba(0,255,122,0.12);outline-offset:2px}
code{background:rgba(255,255,255,0.02);padding:2px 6px;border-radius:6px;font-family:monospace}
</style>
</head>
<body>
<div class="container">
  <div class="shell" role="main" aria-label="Painel cibernético de reconhecimento facial">
    <div class="holo" aria-hidden="true"></div>
    <div class="scanline" aria-hidden="true"></div>

    <aside class="panel" aria-labelledby="panel-title">
      <div class="brand">
        <div class="logo" aria-hidden="true">CY</div>
        <div class="title">
          <h1 id="panel-title">Reconhecimento Facial — Cyber Verde</h1>
          <p>Interface cibernética; modelo local Teachable Machine</p>
        </div>
      </div>

      <div class="controls" aria-live="polite">
        <div class="row">
          <button id="start-btn" class="btn primary" type="button">Start</button>
          <button id="pause-btn" class="btn ghost small" type="button" aria-pressed="false">Pausar câmera</button>
          <button id="clear-labels" class="btn ghost small" type="button">Limpar previsões</button>
        </div>

        <div class="status" role="status" aria-atomic="true">
          <div style="display:flex;justify-content:space-between;align-items:center">
            <strong style="color:var(--neon)">Sistema</strong>
            <span style="color:var(--muted);font-size:13px">Segurança: ON</span>
          </div>

          <div class="readouts" style="margin-top:8px">
            <div class="readout"><strong id="status-text">Aguardando</strong><span style="color:var(--muted);font-size:12px">Status</span></div>
            <div class="readout"><strong id="cam-res">—</strong><span style="color:var(--muted);font-size:12px">Resolução</span></div>
            <div class="readout"><strong id="pred-count">—</strong><span style="color:var(--muted);font-size:12px">Classes</span></div>
          </div>

          <div style="margin-top:10px;color:var(--muted);font-size:13px">Ao iniciar, a página previne novas janelas e garante apenas uma instância ativa da câmera.</div>
        </div>
      </div>
    </aside>

    <section class="view" aria-labelledby="view-title">
      <div class="viewer">
        <div class="viewer-head">
          <div>
            <strong id="view-title">Visor Cibernético</strong>
            <div class="meta">Canvas ao vivo e previsões em HUD</div>
          </div>
          <div class="meta">Modelo local: <code>./my_model/</code></div>
        </div>

        <div id="webcam-container" aria-label="Container da webcam">
          <div style="color:var(--muted);font-weight:700">Teachable Machine Image Model</div>
        </div>

        <div id="label-container" role="status" aria-atomic="true" aria-live="polite">
          <!-- 3 chips iniciais garantidos para visibilidade -->
          <div class="hud-chip"><div class="label">Classe 1</div><div class="prob">—</div></div>
          <div class="hud-chip"><div class="label">Classe 2</div><div class="prob">—</div></div>
          <div class="hud-chip"><div class="label">Classe 3</div><div class="prob">—</div></div>
        </div>

        <div class="foot">
          <div class="meta">Bibliotecas: TensorFlow.js · Teachable Machine</div>
          <div class="meta">Design: Cyber Verde HUD</div>
        </div>
      </div>
    </section>
  </div>
</div>

<!-- bibliotecas e script original com proteção contra múltiplas janelas e instâncias -->
<script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@latest/dist/tf.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@teachablemachine/image@latest/dist/teachablemachine-image.min.js"></script>

<script>
/* URL do modelo local */
const URL = "./my_model/";

let model, webcam, labelContainer, maxPredictions;

/* preserva referência original de window.open */
if (!window.__origOpen) window.__origOpen = window.open;
let openLocked = false;

/* bloqueia aberturas de janelas e links _blank */
function lockWindowOpenOnce(){
  if (openLocked) return;
  try {
    window.open = function(){ return null; };
    document.addEventListener('click', function stopBlank(e){
      const a = e.target.closest && e.target.closest('a');
      if (a && a.target === '_blank') e.preventDefault();
    }, {capture:true});
    openLocked = true;
  } catch(e){
    console.warn('Falha ao bloquear aberturas de janela', e);
  }
}

/* limpa instância anterior da webcam e canvases para evitar duplicação */
function cleanupPreviousWebcam(){
  try {
    if (webcam) {
      if (typeof webcam.stop === 'function') webcam.stop();
      else if (webcam.webcam && webcam.webcam.video && webcam.webcam.video.srcObject){
        const stream = webcam.webcam.video.srcObject;
        stream.getTracks().forEach(t => t.stop());
      }
    }
  } catch(e){ console.warn('Erro ao parar webcam anterior', e); }
  const wc = document.getElementById('webcam-container');
  if (wc) {
    const olds = wc.querySelectorAll('canvas, video');
    olds.forEach(n=>n.remove());
  }
  webcam = null;
}

/* inicializa modelo e webcam de forma segura */
async function init(){
  lockWindowOpenOnce();
  cleanupPreviousWebcam();

  const modelURL = URL + "model.json";
  const metadataURL = URL + "metadata.json";

  model = await tmImage.load(modelURL, metadataURL);
  maxPredictions = model.getTotalClasses();

  // criar webcam com tamanho suficiente
  webcam = new tmImage.Webcam(640, 480, true);
  await webcam.setup();

  // garante playsinline/autoplay para evitar comportamentos que abrem novas janelas em mobile
  try {
    if (webcam.webcam && webcam.webcam.video){
      webcam.webcam.video.setAttribute('playsinline','');
      webcam.webcam.video.setAttribute('muted','');
      webcam.webcam.video.setAttribute('autoplay','');
    }
  } catch(e){}

  await webcam.play();

  // insere canvas único
  const container = document.getElementById('webcam-container');
  container.appendChild(webcam.canvas);

  // cria labels HUD corretamente com prioridade para 3 visíveis
  labelContainer = document.getElementById('label-container');
  labelContainer.innerHTML = '';
  // show up to 3 labels; if model has fewer than 3, still show placeholders
  const showCount = Math.max(3, Math.min(3, maxPredictions));
  for (let i = 0; i < showCount; i++){
    const d = document.createElement('div');
    d.className = 'hud-chip';
    const name = document.createElement('div');
    name.className = 'label';
    name.textContent = (i < maxPredictions) ? model.getClassMetadata ? model.getClassMetadata(i).name || ('Classe ' + (i+1)) : ('Classe ' + (i+1)) : ('Classe ' + (i+1));
    const prob = document.createElement('div');
    prob.className = 'prob';
    prob.textContent = '—';
    d.appendChild(name);
    d.appendChild(prob);
    labelContainer.appendChild(d);
  }

  // se houver mais classes, armazena extras invisíveis (não mostradas) — prioritiza as 3 primeiras
  // atualiza readouts
  const resEl = document.getElementById('cam-res');
  if (resEl) resEl.textContent = webcam.canvas.width + '×' + webcam.canvas.height;
  const pc = document.getElementById('pred-count');
  if (pc) pc.textContent = String(maxPredictions);

  // inicia loop
  window.requestAnimationFrame(loop);
}

/* loop principal */
async function loop(){
  if (!webcam) return;
  try {
    webcam.update();
    await predict();
  } catch(e){
    console.warn('Erro no loop', e);
  }
  window.requestAnimationFrame(loop);
}

/* previsões e atualização do HUD — garante mostrar as 3 chips prioritárias */
async function predict(){
  if (!model || !webcam) return;
  const prediction = await model.predict(webcam.canvas);
  // atualiza os primeiros 3 elementos visíveis
  const chips = labelContainer.querySelectorAll('.hud-chip');
  for (let i = 0; i < chips.length; i++){
    const chip = chips[i];
    if (!chip) continue;
    if (i < prediction.length){
      const p = prediction[i].probability;
      const name = prediction[i].className;
      chip.querySelector('.label').textContent = name;
      chip.querySelector('.prob').textContent = (p*100).toFixed(0) + '%';
      // estilo condicional
      if (p > 0.75){
        chip.style.boxShadow = '0 12px 36px rgba(0,255,122,0.18)';
        chip.style.borderColor = 'rgba(0,255,122,0.14)';
      } else if (p > 0.4){
        chip.style.boxShadow = '0 8px 22px rgba(0,208,106,0.10)';
        chip.style.borderColor = 'rgba(0,208,106,0.10)';
      } else {
        chip.style.boxShadow = '0 6px 16px rgba(0,0,0,0.25)';
        chip.style.borderColor = 'rgba(0,255,122,0.06)';
      }
    } else {
      // placeholder when model has fewer classes
      chip.querySelector('.label').textContent = '—';
      chip.querySelector('.prob').textContent = '—';
      chip.style.boxShadow = 'none';
    }
  }
}
</script>

<script>
/* UI controls: Start, Pause/Resume, Clear; previne múltiplas janelas ao clicar */
(function(){
  const startBtn = document.getElementById('start-btn');
  const pauseBtn = document.getElementById('pause-btn');
  const clearBtn = document.getElementById('clear-labels');
  const statusText = document.getElementById('status-text');

  let isPaused = false;

  startBtn.addEventListener('click', async function(){
    startBtn.disabled = true;
    startBtn.textContent = 'Carregando...';
    try {
      await init();
      statusText.textContent = 'Ativo';
    } catch(e){
      console.error('Falha ao iniciar a câmera', e);
      statusText.textContent = 'Erro';
    } finally {
      startBtn.disabled = false;
      startBtn.textContent = 'Start';
    }
  });

  pauseBtn.addEventListener('click', async function(){
    if (!webcam){
      isPaused = !isPaused;
      pauseBtn.textContent = isPaused ? 'Retomar câmera' : 'Pausar câmera';
      pauseBtn.setAttribute('aria-pressed', String(isPaused));
      return;
    }
    if (!isPaused){
      try {
        if (typeof webcam.stop === 'function') webcam.stop();
        else if (webcam.webcam && webcam.webcam.video && webcam.webcam.video.srcObject){
          webcam.webcam.video.srcObject.getTracks().forEach(t=>t.stop());
        }
        statusText.textContent = 'Pausado';
      } catch(e){ console.warn('Erro ao pausar', e); }
      pauseBtn.textContent = 'Retomar câmera';
      pauseBtn.setAttribute('aria-pressed','true');
      isPaused = true;
    } else {
      try {
        if (typeof webcam.play === 'function') await webcam.play();
        else if (webcam.webcam && webcam.webcam.video) await webcam.webcam.video.play();
        window.requestAnimationFrame(loop);
        statusText.textContent = 'Ativo';
      } catch(e){ console.warn('Erro ao retomar', e); }
      pauseBtn.textContent = 'Pausar câmera';
      pauseBtn.setAttribute('aria-pressed','false');
      isPaused = false;
    }
  });

  clearBtn.addEventListener('click', function(){
    const lc = document.getElementById('label-container');
    if (!lc) return;
    // reset to three visible chips
    lc.innerHTML = '';
    for (let i=0;i<3;i++){
      const d = document.createElement('div');
      d.className = 'hud-chip';
      d.innerHTML = '<div class="label">Classe ' + (i+1) + '</div><div class="prob">—</div>';
      lc.appendChild(d);
    }
    const st = document.getElementById('status-text');
    if (st) st.textContent = 'Previsões limpas';
  });

  // garantir bloqueio de window.open após primeira interação do usuário
  document.addEventListener('pointerdown', function once(){
    try {
      if (!window.openLocked) {
        if (!window.__origOpen) window.__origOpen = window.open;
        window.open = function(){ return null; };
        document.addEventListener('click', function stopBlank(e){
          const a = e.target.closest && e.target.closest('a');
          if (a && a.target === '_blank') e.preventDefault();
        }, {capture:true});
        window.openLocked = true;
      }
    } catch(e){}
    document.removeEventListener('pointerdown', once);
  });

})();
</script>
</body>
</html>
```
